原型模式：使用原型实例指定创建对象的种类，并且通过拷贝原型对象创建新的对象。   
应用场景：
1. 资源优化场景。 
2. 类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。
3. 性能和安全要求的场景。 
4. 通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 
5. 一个对象多个修改者的场景。 
6. 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 
7. 在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。
  
原型模式的组件：
- Prototype（抽象原型）：规定了具体原型对象必须实现的接口。（java中就是java.lang.Cloneable接口）
- ConcretePrototype（具体原型）：从抽象原型派生而来，是客户程序使用的对象，即被复制的对象，需要实现抽象原型角色所要求的接口。
- Client（客户）：使用原型对象的客户程序

原型模式组件示例：
* 抽象原型：java.lang.Cloneable  
* 具体原型：java.util.TreeMap  
  
原型模式总结：
- 原型模式对客户隐藏了具体的产品类
- 运行时刻增加和删除产品：原型模式允许只通过客户注册原型实例就可以将一个新的具体产品类并入系统。
- 减少原型类的构造：是直接克隆一个原型对象而不是通过构造器生成
- 使用原型模式创建对象比直接new一个对象在性能上要好的多，因为Object类的clone方法是一个本地方法，直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。
- 使用原型模式的另一个好处是简化对象的创建，使得创建对象很简单。
- 每一个抽象原型Prototype的子类都必须实现clone操作，实现clone函数可能会很困难。

注意事项：原型模式依据实现方式分浅克隆和深克隆两种
* 浅克隆：对于基本类型会复制值，对于引用类型会直接引用该地址（Object对象的克隆方法是浅克隆）
* 深克隆：对于基本类型会复制值，对于引用类型会在内存中复制一份全新的（序列化是实现深克隆比较好的方案）


